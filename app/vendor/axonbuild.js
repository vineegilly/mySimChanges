var axon =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\nmodule.exports = {\n  Property: __webpack_require__(2),\n  PropertySet: __webpack_require__(7),\n  DerivedProperty: __webpack_require__(9),\n  Events: __webpack_require__(5),\n  MultiLink: __webpack_require__(10),\n  ObservableArray: __webpack_require__(1),\n  arrayRemove: __webpack_require__(11),\n  inherit: __webpack_require__(3),\n  EventTimer: __webpack_require__(12),\n  cleanArray: __webpack_require__(6)\n};\n\n/*****************\n ** WEBPACK FOOTER\n ** ./app/scripts/axon.js\n ** module id = 0\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./app/scripts/axon.js?");

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	eval("/**\n * An observable array of items.\n * <p>\n * Because the array is observable, we must be careful about the possibility of concurrent-modification errors.\n * Any time we iterate over the array, we must iterate over a copy, because callback may be modifying the array.\n *\n * @author Sam Reid\n * @author Chris Malley\n */\n\n// modules\n\"use strict\";\n\nvar Property = __webpack_require__(2);\nvar inherit = __webpack_require__(3);\nvar Events = __webpack_require__(5);\n\nvar ObservableArray = function ObservableArray(array, options) {\n\n  // Special case that the user supplied options but no array\n  if (array instanceof Object && !(array instanceof Array)) {\n    options = array;\n    array = null;\n  }\n\n  this._options = _.extend({\n    allowDuplicates: false, // are duplicate items allowed in the array?\n    tandem: null // Tandem is supported here.  This line doesn't do anything different than leaving tandem as undefined\n    // but this entry serves as an indicator that tandem is supported here.\n  }, options);\n\n  this._array = array || []; // internal, do not access directly\n  this._addedListeners = []; // listeners called when an item is added\n  this._removedListeners = []; // listeners called when an item is removed\n\n  this.lengthProperty = new Property(this._array.length); // observe this, but don't set it\n\n  //Store the initial array, if any, for resetting, see #4\n  this.initialArray = array ? array.slice() : [];\n\n  // Event stream for signifying begin/end of callbacks\n  this.events = new Events();\n\n  options && options.tandem && options.tandem.addInstance(this);\n  this.disposeObservableArray = function () {\n    options && options.tandem && options.tandem.removeInstance(this);\n  };\n};\n\ninherit(Object, ObservableArray, Object.defineProperties({\n\n  dispose: function dispose() {\n    this.disposeObservableArray();\n  },\n\n  //Restore the array back to its initial state\n  //Note: if an item is in the current array and original array, it is removed and added back\n  //This may or may not change in the future, see #4\n  reset: function reset() {\n    for (var i = 0; i < this._array.length; i++) {\n      this._fireItemRemoved(this._array[i]);\n    }\n    this._array = this.initialArray.slice();\n    for (i = 0; i < this._array.length; i++) {\n      this._fireItemAdded(this._array[i]);\n    }\n  },\n\n  /**\n   * Adds a listener that will be notified when an item is added to the list.\n   * @param listener function( item, observableArray )\n   */\n  addItemAddedListener: function addItemAddedListener(listener) {\n    assert && assert(this._addedListeners.indexOf(listener) === -1); // listener is not already registered\n    this._addedListeners.push(listener);\n  },\n\n  /**\n   * Removes a listener that was added via addItemAddedListener.\n   * @param listener\n   */\n  removeItemAddedListener: function removeItemAddedListener(listener) {\n    var index = this._addedListeners.indexOf(listener);\n    assert && assert(index !== -1); // listener is registered\n    this._addedListeners.splice(index, 1);\n  },\n\n  /**\n   * Adds a listener that will be notified when an item is removed from the list.\n   * @param listener function( item, observableArray )\n   */\n  addItemRemovedListener: function addItemRemovedListener(listener) {\n    assert && assert(this._removedListeners.indexOf(listener) === -1); // listener is not already registered\n    this._removedListeners.push(listener);\n  },\n\n  /**\n   * Removes a listener that was added via addItemRemovedListener.\n   * @param listener\n   */\n  removeItemRemovedListener: function removeItemRemovedListener(listener) {\n    var index = this._removedListeners.indexOf(listener);\n    assert && assert(index !== -1); // listener is registered\n    this._removedListeners.splice(index, 1);\n  },\n\n  /**\n   * Convenience function for adding both types of listeners in one shot.\n   * @param itemAddedListener\n   * @param itemRemovedListener\n   */\n  addListeners: function addListeners(itemAddedListener, itemRemovedListener) {\n    this.addItemAddedListener(itemAddedListener);\n    this.addItemRemovedListener(itemRemovedListener);\n  },\n\n  // Internal: called when an item is added.\n  _fireItemAdded: function _fireItemAdded(item) {\n\n    this.events.trigger1(\"startedCallbacksForItemAdded\", item);\n\n    //Signify that an item was added to the list\n    var copy = this._addedListeners.slice(0); // operate on a copy, firing could result in the listeners changing\n    for (var i = 0; i < copy.length; i++) {\n      copy[i](item, this);\n    }\n\n    this.events.trigger0(\"endedCallbacksForItemAdded\");\n  },\n\n  // Internal: called when an item is removed.\n  _fireItemRemoved: function _fireItemRemoved(item) {\n\n    this.events.trigger1(\"startedCallbacksForItemRemoved\", item);\n\n    //Signify that an item was removed from the list\n    var copy = this._removedListeners.slice(0); // operate on a copy, firing could result in the listeners changing\n    for (var i = 0; i < copy.length; i++) {\n      copy[i](item, this);\n    }\n\n    this.events.trigger1(\"startedCallbacksForItemRemoved\", item);\n  },\n\n  /**\n   * Adds an item to the end of the array.\n   * This is a convenience function, and is the same as push.\n   * @param item\n   */\n  add: function add(item) {\n    this.push(item);\n  },\n\n  /**\n   * Add items to the end of the array.\n   * This is a convenience function, and is the same as push.\n   * @param {Array} items\n   */\n  addAll: function addAll(items) {\n    for (var i = 0; i < items.length; i++) {\n      this.add(items[i]);\n    }\n  },\n\n  /**\n   * Removes the first occurrence of an item from the array.\n   * If duplicates are allowed (see options.allowDuplicates) you may need to call this multiple\n   * times to totally purge item from the array.\n   * @param item\n   */\n  remove: function remove(item) {\n    var index = this._array.indexOf(item);\n    if (index !== -1) {\n      this._array.splice(index, 1);\n      this.lengthProperty.set(this._array.length);\n      this._fireItemRemoved(item);\n    }\n  },\n\n  /**\n   * Removes the first occurrence of each item in the specified array.\n   * @param {Array} list a list of items to remove\n   * @see ObservableArray.remove\n   */\n  removeAll: function removeAll(list) {\n    for (var i = 0; i < list.length; i++) {\n      var item = list[i];\n      this.remove(item);\n    }\n  },\n\n  /**\n   * Pushes an item onto the end of the array.\n   * @param item\n   * @throws Error if duplicates are not allowed (see options.allowDuplicates) and item is already in the array\n   */\n  push: function push(item) {\n    if (!this._options.allowDuplicates && this.contains(item)) {\n      throw new Error(\"duplicates are not allowed\");\n    }\n    this._array.push(item);\n    this.lengthProperty.set(this._array.length);\n    this._fireItemAdded(item);\n  },\n\n  /**\n   * Removes an item from the end of the array and returns it.\n   * @returns {*}\n   */\n  pop: function pop() {\n    var item = this._array.pop();\n    if (item !== undefined) {\n      this.lengthProperty.set(this._array.length);\n      this._fireItemRemoved(item);\n    }\n    return item;\n  },\n\n  /**\n   * Removes an item from the beginning of the array and returns it.\n   * @returns {*}\n   */\n  shift: function shift() {\n    var item = this._array.shift();\n    if (item !== undefined) {\n      this.lengthProperty.set(this._array.length);\n      this._fireItemRemoved(item);\n    }\n    return item;\n  },\n\n  /**\n   * Does the array contain the specified item?\n   * @param item\n   * @returns {boolean}\n   */\n  contains: function contains(item) {\n    return this.indexOf(item) !== -1;\n  },\n\n  /**\n   * Gets an item at the specified index.\n   * @param index\n   * @returns {*} the item, or undefined if there is no item at the specified index\n   */\n  get: function get(index) {\n    return this._array[index];\n  },\n\n  /**\n   * Gets the index of a specified item.\n   * @param item\n   * @returns {*} -1 if item is not in the array\n   */\n  indexOf: function indexOf(item) {\n    return this._array.indexOf(item);\n  },\n\n  /**\n   * Removes all items from the array.\n   */\n  clear: function clear() {\n    var copy = this._array.slice(0);\n    for (var i = 0; i < copy.length; i++) {\n      this.remove(copy[i]);\n    }\n  },\n\n  /**\n   * Applies a callback function to each item in the array\n   * @param callback function(item)\n   */\n  forEach: function forEach(callback) {\n    this._array.slice().forEach(callback); // do this on a copy of the array, in case callbacks involve array modification\n  },\n\n  /**\n   * Maps the values in this ObservableArray using the specified function, and returns a new ObservableArray for chaining.\n   * @param mapFunction\n   * @returns {axon.ObservableArray}\n   */\n  map: function map(mapFunction) {\n    return new axon.ObservableArray(this._array.map(mapFunction));\n  },\n\n  /**\n   * Starting with the initial value, combine values from this ObservableArray to come up with a composite result.\n   * Same as foldLeft.  In underscore this is called _.reduce aka _.foldl or _.inject\n   * @param value\n   * @param combiner\n   * @returns {*}\n   */\n  reduce: function reduce(value, combiner) {\n    for (var i = 0; i < this._array.length; i++) {\n      value = combiner(value, this._array[i]);\n    }\n    return value;\n  },\n\n  /**\n   * Return the underlying array\n   * @returns {*|Array}\n   */\n  getArray: function getArray() {\n    return this._array;\n  },\n\n  setElements: function setElements(elements) {\n\n    // TODO: do a better diff here for efficiency\n    this.clear();\n    this.addAll(elements);\n  }\n}, {\n  length: {\n    get: function () {\n      return this._array.length;\n    },\n    configurable: true,\n    enumerable: true\n  }\n}));\n\nmodule.exports = ObservableArray;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./app/scripts/axon/ObservableArray.js\n ** module id = 1\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./app/scripts/axon/ObservableArray.js?");

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	eval("\n/**\n * An observable property, notifies registered observers when the value changes.\n *\n * Uses the 'Constructor' pattern for object creation, which has the downside that\n * all properties are created once for each instance. It would be nice if our functions\n * were shared. But since the only way to create private fields is in the constructor,\n * and the functions need access to those private fields, there doesn't seem to be\n * any choice but to define the functions in the constructor.\n *\n * @author Sam Reid\n * @author Chris Malley (PixelZoom, Inc.)\n */\n\n// modules\n\"use strict\";\n\nvar inherit = __webpack_require__(3);\nvar Events = __webpack_require__(5);\n\n// Also requires Multilink and DerivedProperty, but cannot reference them here or it will create a\n// circular dependency.  So they are loaded through axon.Multilink and axon.DerivedProperty.\n\n/**\n * @param {*} value - the initial value of the property\n * @param {Object} [options] - options\n * @constructor\n */\nvar Property = function Property(value, options) {\n\n  options = _.extend({ tandem: null }, options);\n\n  // Internal Events for sending startedCallbacksForChanged & endedCallbacksForChanged\n  this.events = new Events();\n\n  //Store the internal value and the initial value\n  this.storeValue(value); // typically sets this._value\n  this.storeInitialValue(value); // typically sets this._initialValue\n  this._observers = [];\n\n  options.tandem && options.tandem.addInstance(this);\n\n  // @private\n  this.disposeProperty = function () {\n    options.tandem && options.tandem.removeInstance(this);\n    while (this._observers.length > 0) {\n      this.unlink(this._observers[0]);\n    }\n  };\n};\n\ninherit(Object, Property, Object.defineProperties({\n\n  /**\n   * Gets the value.  You can also use the es5 getter (property.value) but this means is provided for inner loops or internal code that must be fast.\n   * @return {*}\n   */\n  get: function get() {\n    return this._value;\n  },\n\n  /**\n   * Sets the value and notifies registered observers.  You can also use the es5 getter (property.value) but this means is provided for inner loops or internal code that must be fast.\n   * If the value hasn't changed, this is a no-op.\n   *\n   * @param {*} value\n   */\n  set: function set(value) {\n    if (!this.equalsValue(value)) {\n      this._setAndNotifyObservers(value);\n    }\n    return this;\n  },\n\n  // whether this property will not \"change\" when the passed-in value is set\n  equalsValue: function equalsValue(value) {\n    return value === this._value;\n  },\n\n  // store the current (new) value\n  storeValue: function storeValue(value) {\n    this._value = value;\n  },\n\n  // store the initial value\n  storeInitialValue: function storeInitialValue(value) {\n    this._initialValue = value;\n  },\n\n  _setAndNotifyObservers: function _setAndNotifyObservers(value) {\n    var oldValue = this.get();\n    this.storeValue(value);\n    this._notifyObservers(oldValue);\n  },\n\n  _notifyObservers: function _notifyObservers(oldValue) {\n\n    // Note the current value, since it will be sent to possibly multiple observers.\n    var value = this.get();\n\n    // TODO: Should Property extend or compose Events?  Would extending Events broaden its interface too much?\n    this.events.trigger2(\"startedCallbacksForChanged\", value, oldValue);\n\n    var observersCopy = this._observers.slice(); // make a copy, in case notification results in removeObserver\n    for (var i = 0; i < observersCopy.length; i++) {\n      observersCopy[i](value, oldValue);\n    }\n\n    this.events.trigger0(\"endedCallbacksForChanged\");\n  },\n\n  /**\n   * Use this method when mutating a value (not replacing with a new instance) and you want to send notifications about the change.\n   * This is different from the normal axon strategy, but may be necessary to prevent memory allocations.\n   * This method is unsafe for removing observers because it assumes the observer list not modified, to save another allocation\n   * Only provides the new reference as a callback (no oldvalue)\n   * See https://github.com/phetsims/axon/issues/6\n   */\n  notifyObserversStatic: function notifyObserversStatic() {\n    var value = this.get();\n    for (var i = 0; i < this._observers.length; i++) {\n      this._observers[i](value);\n    }\n  },\n\n  /**\n   * Resets the value to the initial value.\n   */\n  reset: function reset() {\n    this.set(this._initialValue);\n  },\n\n  /**\n   * This function returns a bound function that sets the specified value.  For use in creating closures e.g. with gui classes.\n   * For instance, to have a button that sets a property to true, instead of using\n   * button.click(function(){property.set(true);});\n   * you could use\n   * button.click(property._set(true));\n   * @param value the value to use when the setter is called.\n   * @return a function that can be used to set the specified value.\n   */\n  _set: function _set(value) {\n    return this.set.bind(this, value);\n  },\n\n  /**\n   * Adds an observer and notifies it immediately.\n   * If observer is already registered, this is a no-op.\n   * The initial notification provides the current value for newValue and null for oldValue.\n   *\n   * @param {function} observer a function of the form observer(newValue,oldValue)\n   */\n  link: function link(observer) {\n    if (this._observers.indexOf(observer) === -1) {\n      this._observers.push(observer);\n      observer(this.get(), null); // null should be used when an object is expected but unavailable\n    }\n  },\n\n  /**\n   * Add an observer to the Property, without calling it back right away.  This is used when you need to register a observer without an immediate callback.\n   * @param {function} observer  a function with a single argument, which is the value of the property at the time the function is called.\n   */\n  lazyLink: function lazyLink(observer) {\n    if (this._observers.indexOf(observer) === -1) {\n      this._observers.push(observer);\n    }\n  },\n\n  /**\n   * Removes an observer.\n   * If observer is not registered, this is a no-op.\n   *\n   * @param {function} observer\n   */\n  unlink: function unlink(observer) {\n    var index = this._observers.indexOf(observer);\n    if (index !== -1) {\n      this._observers.splice(index, 1);\n    }\n  },\n\n  /**\n   * Links an object's named attribute to this property.  Returns a handle so it can be removed using Property.unlink();\n   * Example: modelVisibleProperty.linkAttribute(view,'visible');\n   *\n   * @param object\n   * @param attributeName\n   */\n  linkAttribute: function linkAttribute(object, attributeName) {\n    var handle = function handle(value) {\n      object[attributeName] = value;\n    };\n    this.link(handle);\n    return handle;\n  },\n\n  /**\n   * Unlink an observer added with linkAttribute.  Note: the args of linkAttribute do not match the args of\n   * unlinkAttribute: here, you must pass the observer handle returned by linkAttribute rather than object and attributeName\n   * @param observer\n   */\n  unlinkAttribute: function unlinkAttribute(observer) {\n    this.unlink(observer);\n  },\n\n  //Provide toString for console debugging, see http://stackoverflow.com/questions/2485632/valueof-vs-tostring-in-javascript\n  toString: function toString() {\n    return \"Property{\" + this.get() + \"}\";\n  },\n  valueOf: function valueOf() {\n    return this.toString();\n  },\n\n  /**\n   * Add an observer so that it will only fire once (and not on registration)\n   *\n   * I can see two ways to implement this:\n   * (a) add a field to the observer so after notifications it can be checked and possibly removed. Disadvantage: will make everything slower even if not using 'once'\n   * (b) wrap the observer in a new function which will call the observer and then remove itself.  Disadvantage: cannot remove an observer added using 'once'\n   * To avoid possible performance problems, use a wrapper function, and return it as a handle in case the 'once' observer must be removed before it is called once\n   *\n   * @param observer the observer which should be called back only for one property change (and not on registration)\n   * @returns {function} the wrapper handle in case the wrapped function needs to be removed with 'unlink' before it is called once\n   */\n  once: function once(observer) {\n    var property = this;\n    var wrapper = (function (_wrapper) {\n      var _wrapperWrapper = function wrapper(_x, _x2) {\n        return _wrapper.apply(this, arguments);\n      };\n\n      _wrapperWrapper.toString = function () {\n        return _wrapper.toString();\n      };\n\n      return _wrapperWrapper;\n    })(function (newValue, oldValue) {\n      property.unlink(wrapper);\n      observer(newValue, oldValue);\n    });\n    this.lazyLink(wrapper);\n    return wrapper;\n  },\n\n  /**\n   * Convenience function for debugging a property values.  It prints the new value on registration and when changed.\n   * @param name debug name to be printed on the console\n   * @returns {function} the handle to the linked observer in case it needs to be removed later\n   */\n  debug: function debug(name) {\n    var observer = function observer(value) {\n      console.log(name, value);\n    };\n    this.link(observer);\n    return observer;\n  },\n\n  /**\n   * Modifies the value of this Property with the ! operator.  Works for booleans and non-booleans.\n   */\n  toggle: function toggle() {\n    this.value = !this.value;\n  },\n\n  /**\n   * Adds an observer that is fired when the property takes the specified value.  If the property has the value already,\n   * the observer is called back immediately.  A reference to the observer is returned so that it can be removed.\n   *\n   * @param value the value to match\n   * @param observer the observer that is called when this Property\n   */\n  onValue: function onValue(value, observer) {\n    var onValueObserver = function onValueObserver(v) {\n      if (v === value) {\n        observer();\n      }\n    };\n    this.link(onValueObserver);\n    return onValueObserver;\n  },\n\n  // Ensures that the Property is eligible for GC\n  dispose: function dispose() {\n    this.disposeProperty();\n  }\n}, {\n  initialValue: {\n    get: function () {\n      return this._initialValue;\n    },\n    configurable: true,\n    enumerable: true\n  },\n  value: {\n    get: function () {\n      return this.get();\n    },\n    set: function (newValue) {\n      this.set(newValue);\n    },\n    configurable: true,\n    enumerable: true\n  },\n  toggleFunction: {\n    get: function () {\n      return this.toggle.bind(this);\n    },\n    configurable: true,\n    enumerable: true\n  }\n}),\n\n//statics\n{\n\n  /**\n   * Registers an observer with multiple properties, then notifies the observer immediately.\n   * @param {Property[]} properties\n   * @param {function} observer no params, returns nothing\n   * @static\n   */\n  multilink: function multilink(properties, observer) {\n    return new axon.Multilink(properties, observer, false);\n  },\n\n  lazyMultilink: function lazyMultilink(properties, observer) {\n    return new axon.Multilink(properties, observer, true);\n  },\n\n  /**\n   * Removes the multilinked observer from this Property.\n   * Same as calling dispose() on the handle (which happens to be a DerivedProperty instance)\n   * @param {DerivedProperty} derivedProperty\n   */\n  unmultilink: function unmultilink(derivedProperty) {\n    derivedProperty.dispose();\n  },\n\n  /**\n   * Set up a PropertySet-like property on any object (see https://github.com/phetsims/axon/issues/42).\n   *\n   * @param {Object} object - The object that the property will be placed on\n   * @param {string} propertyName - Name of the property\n   * @param {*} initialValue - The initial value of the property\n   */\n  addProperty: function addProperty(object, propertyName, initialValue) {\n    // defines the property\n    var property = this[propertyName + \"Property\"] = new axon.Property(initialValue);\n\n    // defines ES5 getter/setter\n    Object.defineProperty(this, propertyName, {\n      get: function get() {\n        return property.get();\n      },\n      set: function set(value) {\n        property.set(value);\n      },\n\n      // Make it configurable and enumerable so it's easy to override...\n      configurable: true,\n      enumerable: true\n    });\n  }\n});\n\nmodule.exports = Property;\n\n/**\n * Returns a function that can be used to toggle the property (using !)\n * @returns {function}\n */\n\n/*****************\n ** WEBPACK FOOTER\n ** ./app/scripts/axon/Property.js\n ** module id = 2\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./app/scripts/axon/Property.js?");

/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	eval("/**\n * Utility function for setting up prototypal inheritance.\n * Maintains supertype.prototype.constructor while properly copying ES5 getters and setters.\n * Supports adding functions to both the prototype itself and the constructor function.\n *\n * Usage:\n *\n * // Call the supertype constructor somewhere in the subtype's constructor.\n * function A() { scenery.Node.call( this ); };\n *\n * // Add prototype functions and/or 'static' functions\n * return inherit( scenery.Node, A, {\n *   customBehavior: function() { ... },\n *   isAnA: true\n * }, {\n *   someStaticFunction: function() { ...}\n * } );\n *\n * // client calls\n * new A().isAnA; // true\n * new scenery.Node().isAnA; // undefined\n * new A().constructor.name; // 'A'\n * A.someStaticFunction();\n *\n */\n\n\"use strict\";\n\nvar extend = __webpack_require__(4);\n\n/**\n * @param supertype           Constructor for the supertype.\n * @param subtype             Constructor for the subtype. Generally should contain supertype.call( this, ... )\n * @param prototypeProperties [optional] object containing properties that will be set on the prototype.\n * @param staticProperties [optional] object containing properties that will be set on the constructor function itself\n */\nvar inherit = function inherit(supertype, subtype, prototypeProperties, staticProperties) {\n\n  function F() {}\n\n  F.prototype = supertype.prototype; // so new F().__proto__ === supertype.prototype\n\n  subtype.prototype = extend( // extend will combine the properties and constructor into the new F copy\n  new F(), // so new F().__proto__ === supertype.prototype, and the prototype chain is set up nicely\n  { constructor: subtype }, // overrides the constructor properly\n  prototypeProperties // [optional] additional properties for the prototype, as an object.\n  );\n\n  //Copy the static properties onto the subtype constructor so they can be accessed 'statically'\n  extend(subtype, staticProperties);\n\n  return subtype; // pass back the subtype so it can be returned immediately as a module export\n};\n\nmodule.exports = inherit;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./app/scripts/axon/inherit.js\n ** module id = 3\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./app/scripts/axon/inherit.js?");

/***/ },
/* 4 */
/***/ function(module, exports) {

	eval("/**\n * Like Underscore's _.extend, but with hardcoded support for ES5 getters/setters.\n */\n\n\"use strict\";\n\nvar extend = function extend(obj) {\n  _.each(Array.prototype.slice.call(arguments, 1), function (source) {\n    if (source) {\n      for (var prop in source) {\n        Object.defineProperty(obj, prop, Object.getOwnPropertyDescriptor(source, prop));\n      }\n    }\n  });\n  return obj;\n};\n\nmodule.exports = extend;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./app/scripts/axon/extend.js\n ** module id = 4\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./app/scripts/axon/extend.js?");

/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	eval("\n\n/**\n * Lightweight event & listener abstraction.\n * @author Sam Reid\n */\n\n\"use strict\";\n\nvar cleanArray = __webpack_require__(6);\n\n/**\n * @class Events\n * @constructor\n */\nvar Events = function Events(options) {\n  this._eventListeners = {}; // @private\n  this._staticEventListeners = {}; // @private\n\n  options && options.tandem && options.tandem.addInstance(this);\n  this.disposeEvents = function () {\n    options && options.tandem && options.tandem.removeInstance(this);\n  };\n};\n\nEvents.prototype = {\n  dispose: function dispose() {\n    this.disposeEvents();\n  },\n\n  /////////////////////////////////////////////\n  // Below this point are the functions for event handling, basically orthogonal to property value change notifications\n\n  /**\n   * Register a listener when the specified eventName is triggered. Use off() to remove.\n   * Concurrent modification of listeners (on/off) from within the callback is acceptable.\n   * @param {string} eventName the name for the event channel\n   * @param {function} callback\n   */\n  on: function on(eventName, callback) {\n    assert && assert(typeof eventName === \"string\", \"eventName should be a string\");\n    assert && assert(typeof callback === \"function\", \"callback should be a function\");\n\n    this._eventListeners[eventName] = this._eventListeners[eventName] || [];\n    this._eventListeners[eventName].push(callback);\n  },\n\n  /**\n   * Register a listener when the specified eventName is triggered. Listener should be \"static\", meaning:\n   *   1. It shall not add/remove any \"static\" listeners (including itself) while it is being called (as any type of side-effect), and\n   *   2. \"static\" listeners should not be added while a non-static listener (on the same object) is being called.\n   * These restrictions allow us to guarantee that all listeners attached when an event is triggered are called.\n   * Since static listeners are stored separately, use offStatic() to remove listeners added with onStatic()\n   * @param {string} eventName the name for the event channel\n   * @param {function} callback\n   */\n  onStatic: function onStatic(eventName, callback) {\n    assert && assert(typeof eventName === \"string\", \"eventName should be a string\");\n    assert && assert(typeof callback === \"function\", \"callback should be a function\");\n\n    this._staticEventListeners[eventName] = this._staticEventListeners[eventName] || [];\n    this._staticEventListeners[eventName].push(callback);\n  },\n\n  /**\n   * Adds a function which will only be called back once, after which it is removed as a listener.\n   * If you need to remove a function added with 'once' you will have to remove its handle, which is returned by the function.\n   * @param {string} eventName the name for the event channel\n   * @param {function} callback function to be called back once (if at all)\n   */\n  once: function once(eventName, callback) {\n    assert && assert(typeof eventName === \"string\", \"eventName should be a string\");\n    assert && assert(typeof callback === \"function\", \"callback should be a function\");\n\n    var events = this;\n    var wrappedCallback = (function (_wrappedCallback) {\n      var _wrappedCallbackWrapper = function wrappedCallback() {\n        return _wrappedCallback.apply(this, arguments);\n      };\n\n      _wrappedCallbackWrapper.toString = function () {\n        return _wrappedCallback.toString();\n      };\n\n      return _wrappedCallbackWrapper;\n    })(function () {\n      events.off(eventName, wrappedCallback);\n\n      //If no arguments being passed through, call back without processing arguments, for possible speed\n      if (arguments.length === 0) {\n        callback();\n      } else {\n\n        //General case of passing events through to the wrapped callback function\n        callback.apply(this, Array.prototype.slice.call(arguments, 0));\n      }\n    });\n    this.on(eventName, wrappedCallback);\n\n    //Return the handle in case it needs to be removed.\n    return wrappedCallback;\n  },\n\n  /**\n   * Remove a listener added with on() from the specified event type.  Does nothing if the listener did not exist.\n   * @param {string} eventName the name for the event channel\n   * @param {function} callback\n   */\n  off: function off(eventName, callback) {\n    assert && assert(typeof eventName === \"string\", \"eventName should be a string\");\n    assert && assert(typeof callback === \"function\", \"callback should be a function\");\n\n    var index = -1;\n    if (this._eventListeners[eventName]) {\n      index = this._eventListeners[eventName].indexOf(callback);\n      if (index !== -1) {\n        this._eventListeners[eventName].splice(index, 1);\n      }\n    }\n\n    return index; // so we can tell if we actually removed a listener\n  },\n\n  /**\n   * Remove a listener added with onStatic() from the specified event type.  Does nothing if the listener did not exist.\n   * @param {string} eventName the name for the event channel\n   * @param {function} callback\n   */\n  offStatic: function offStatic(eventName, callback) {\n    assert && assert(typeof eventName === \"string\", \"eventName should be a string\");\n    assert && assert(typeof callback === \"function\", \"callback should be a function\");\n\n    var index = -1;\n    if (this._staticEventListeners[eventName]) {\n      index = this._staticEventListeners[eventName].indexOf(callback);\n      if (index !== -1) {\n        this._staticEventListeners[eventName].splice(index, 1);\n      }\n    }\n\n    return index; // so we can tell if we actually removed a listener\n  },\n\n  /**\n   * Checks for the existence of a specific listener, attached to a specific event name. Doesn't check for static listeners\n   * @param {string} eventName the name for the event channel\n   * @param {function} callback\n   * @returns {boolean}\n   */\n  hasListener: function hasListener(eventName, callback) {\n    assert && assert(typeof eventName === \"string\", \"eventName should be a string\");\n    assert && assert(typeof callback === \"function\", \"callback should be a function\");\n\n    var array = this._eventListeners[eventName];\n    return !!array && array.indexOf(callback) >= 0;\n  },\n\n  /**\n   * Checks for the existence of a specific static listener, attached to a specific event name. Doesn't check for non-static listeners\n   * @param {string} eventName the name for the event channel\n   * @param {function} callback\n   * @returns {boolean}\n   */\n  hasStaticListener: function hasStaticListener(eventName, callback) {\n    assert && assert(typeof eventName === \"string\", \"eventName should be a string\");\n    assert && assert(typeof callback === \"function\", \"callback should be a function\");\n\n    var array = this._staticEventListeners[eventName];\n    return !!array && array.indexOf(callback) >= 0;\n  },\n\n  /**\n   * Removes all listeners added with on() and onStatic().\n   */\n  removeAllEventListeners: function removeAllEventListeners() {\n    var eventName;\n    for (eventName in this._eventListeners) {\n      cleanArray(this._eventListeners[eventName]);\n    }\n    for (eventName in this._staticEventListeners) {\n      cleanArray(this._staticEventListeners[eventName]);\n    }\n  },\n\n  /**\n   * Trigger an event with the specified name and arguments.\n   * @param {string} eventName the name for the event channel\n   * @param args... optional arguments to pass to the listeners\n   */\n  trigger: function trigger(eventName) {\n    assert && assert(typeof eventName === \"string\", \"eventName should be a string\");\n\n    var listeners = this._eventListeners[eventName];\n    var staticListeners = this._staticEventListeners[eventName];\n\n    // listener quantities for normal and static\n    var count = listeners ? listeners.length : 0;\n    var staticCount = staticListeners ? staticListeners.length : 0;\n\n    // only compute our arguments suffix once, instead of in our inner loop\n    var suffix;\n    var hasNoArguments = arguments.length === 1;\n    if (!hasNoArguments && (count > 0 || staticCount > 0)) {\n      phetAllocation && phetAllocation(\"Array\");\n      suffix = Array.prototype.slice.call(arguments, 1);\n    }\n\n    // make a copy of non-static listeners, in case callback removes listener\n    if (count > 0) {\n      listeners = listeners.slice();\n    }\n\n    var i;\n\n    for (i = 0; i < count; i++) {\n      var listener = listeners[i];\n\n      //Simple case of no arguments, call it separately for improved performance in case it is faster (untested)\n      if (hasNoArguments) {\n        listener();\n      } else {\n        listener.apply(this, suffix);\n      }\n\n      assert && assert(!staticListeners || staticListeners.length === staticCount, \"Concurrent modifications of static listeners from within non-static listeners are forbidden\");\n    }\n\n    for (i = 0; i < staticCount; i++) {\n      var staticListener = staticListeners[i];\n\n      //Simple case of no arguments, call it separately for improved performance in case it is faster (untested)\n      if (hasNoArguments) {\n        staticListener(arguments);\n      } else {\n        staticListener.apply(this, suffix);\n      }\n\n      assert && assert(staticListeners.length === staticCount, \"Concurrent modifications from static listeners are forbidden\");\n    }\n  },\n\n  /**\n   * Trigger an event with the specified name, with no arguments.  Since the number of arguments is known\n   * no additional work is required to process and pass through the arguments (as opposed to trigger() itself).\n   * @param {string} eventName the name for the event channel\n   */\n  trigger0: function trigger0(eventName) {\n    assert && assert(arguments.length === 1);\n    assert && assert(typeof eventName === \"string\", \"eventName should be a string\");\n\n    var listeners = this._eventListeners[eventName];\n    var staticListeners = this._staticEventListeners[eventName];\n\n    // listener quantities for normal and static\n    var count = listeners ? listeners.length : 0;\n    var staticCount = staticListeners ? staticListeners.length : 0;\n\n    // make a copy of non-static listeners, in case callback removes listener\n    if (count > 0) {\n      listeners = listeners.slice();\n    }\n\n    var i;\n\n    for (i = 0; i < count; i++) {\n      listeners[i]();\n\n      assert && assert(!staticListeners || staticListeners.length === staticCount, \"Concurrent modifications of static listeners from within non-static listeners are forbidden\");\n    }\n\n    for (i = 0; i < staticCount; i++) {\n      staticListeners[i]();\n\n      assert && assert(staticListeners.length === staticCount, \"Concurrent modifications from static listeners are forbidden\");\n    }\n  },\n\n  /**\n   * Trigger an event with the specified name, with a single argument.  Since the number of arguments is known\n   * no additional work is required to process and pass through the arguments (as opposed to trigger() itself).\n   * @param {string} eventName the name for the event channel\n   * @param {Object} param1 - the argument to pass through to the listeners\n   */\n  trigger1: function trigger1(eventName, param1) {\n    assert && assert(arguments.length === 2);\n    assert && assert(typeof eventName === \"string\", \"eventName should be a string\");\n\n    var listeners = this._eventListeners[eventName];\n    var staticListeners = this._staticEventListeners[eventName];\n\n    // listener quantities for normal and static\n    var count = listeners ? listeners.length : 0;\n    var staticCount = staticListeners ? staticListeners.length : 0;\n\n    // make a copy of non-static listeners, in case callback removes listener\n    if (count > 0) {\n      listeners = listeners.slice();\n    }\n\n    var i;\n\n    for (i = 0; i < count; i++) {\n      listeners[i](param1);\n\n      assert && assert(!staticListeners || staticListeners.length === staticCount, \"Concurrent modifications of static listeners from within non-static listeners are forbidden\");\n    }\n\n    for (i = 0; i < staticCount; i++) {\n      staticListeners[i](param1);\n\n      assert && assert(staticListeners.length === staticCount, \"Concurrent modifications from static listeners are forbidden\");\n    }\n  },\n\n  /**\n   * Trigger an event with the specified name, with two arguments.  Since the number of arguments is known\n   * no additional work is required to process and pass through the arguments (as opposed to trigger() itself).\n   * @param {string} eventName the name for the event channel\n   * @param {Object} param1 - the first parameter\n   * @param {Object} param2 - the second parameter\n   */\n  trigger2: function trigger2(eventName, param1, param2) {\n    assert && assert(arguments.length === 3);\n    assert && assert(typeof eventName === \"string\", \"eventName should be a string\");\n\n    var listeners = this._eventListeners[eventName];\n    var staticListeners = this._staticEventListeners[eventName];\n\n    // listener quantities for normal and static\n    var count = listeners ? listeners.length : 0;\n    var staticCount = staticListeners ? staticListeners.length : 0;\n\n    // make a copy of non-static listeners, in case callback removes listener\n    if (count > 0) {\n      listeners = listeners.slice();\n    }\n\n    var i;\n\n    for (i = 0; i < count; i++) {\n      listeners[i](param1, param2);\n\n      assert && assert(!staticListeners || staticListeners.length === staticCount, \"Concurrent modifications of static listeners from within non-static listeners are forbidden\");\n    }\n\n    for (i = 0; i < staticCount; i++) {\n      staticListeners[i](param1, param2);\n\n      assert && assert(staticListeners.length === staticCount, \"Concurrent modifications from static listeners are forbidden\");\n    }\n  }\n};\n\nmodule.exports = Events;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./app/scripts/axon/Events.js\n ** module id = 5\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./app/scripts/axon/Events.js?");

/***/ },
/* 6 */
/***/ function(module, exports) {

	eval("\n/**\n * If given an Array, removes all of its elements and returns it. Otherwise, if given a falsy value\n * (null/undefined/etc.), it will create and return a fresh Array.\n *\n * @author Jonathan Olson <jonathan.olson@colorado.edu>\n */\n\n\"use strict\";\n\nvar cleanArray = function cleanArray(arr) {\n  assert && assert(!arr || arr instanceof Array, \"cleanArray either takes an Array\");\n\n  if (arr) {\n    // fastest way to clear an array (http://stackoverflow.com/questions/1232040/how-to-empty-an-array-in-javascript, http://jsperf.com/array-destroy/32)\n    // also, better than length=0, since it doesn't create significant garbage collection (like length=0), tested on Chrome 34.\n    while (arr.length) {\n      arr.pop();\n    }\n    return arr;\n  } else {\n    return [];\n  }\n};\n\nmodule.exports = cleanArray;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./app/scripts/axon/cleanArray.js\n ** module id = 6\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./app/scripts/axon/cleanArray.js?");

/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	eval("/**\n * PropertySet facilitates creation and use of multiple named Property instances.  There are still several API design issues in question, but this\n * class is ready for use.\n *\n * A PropertySet is a set of Property instances that provides support for:\n * -Easily creating several properties using an object literal (hash)\n * -Resetting them as a group\n * -Set multiple values at once, using propertySet.set({x:100,y:200,name:'alice'});\n * -Support for derived properties, which appear with the same interface as basic properties\n * -Convenient toString that prints e.g., PropertySet{name:'larry',age:101,kids:['alice','bob']}\n * -Wiring up to listen to multiple properties simultaneously\n * -Add properties after the PropertySet is created?  Don't forget to add to the key list as well.\n * -Remove properties that were added using addProperty or the constructor\n *\n * Sample usage:\n * var p = new PropertySet( {name: 'larry', age: 100, kids: ['alice', 'bob']} );\n * p.nameProperty.link( function( n ) {console.log( 'hello ' + n );} );\n * p.name = 'jensen';\n * p.age = 101;//Happy Birthday!\n * console.log( p );\n * p.reset();\n * console.log( p );\n * p.set({name:'clark',age:102,kids:['alice','bob','charlie']});\n *\n * How would this be done without PropertySet (for comparison)?\n * //Normally would be created in a class but that is omitted here for brevity.\n * var p ={name: new Property('larry'), age: new Property('age'), kids: new Property(['alice','bob'])}\n * p.reset = function(){\n *   this.name.reset();\n *   this.age.reset();\n *   this.kids.reset();\n * }\n * p.name.set('clark');\n * p.age.set('102');\n * p.kids.set(['alice','bob','charlie']);\n *\n * Note: If a subclass ever substitutes a property like this: person.ageProperty = new Property(person.age), then it would break the getter/setter\n * @author Sam Reid\n */\n\n// modules\n\"use strict\";\n\nvar Property = __webpack_require__(2);\nvar inherit = __webpack_require__(3);\nvar Events = __webpack_require__(5);\nvar Multilink = __webpack_require__(8);\nvar DerivedProperty = __webpack_require__(9);\n\n// constants\nvar SUFFIX = \"Property\";\n\n/**\n * PropertySet main constructor\n * @param {Object} values - a hash: keys are the names of properties, values are initial property values. Eg { name: 'Curly', age: 40 }\n * @param {Object} [options]\n * @constructor\n */\nvar PropertySet = function PropertySet(values, options) {\n\n  options = _.extend({\n    tandemSet: {} // a hash, keys are a subset of the keys in values, and the value associated with each key is a {Tandem} tandem\n  }, options);\n\n  // Verify that the tandemSet doesn't contain bogus keys. filter should return 0 tandemSet keys that are not in values.\n  assert && assert(_.filter(_.keys(options.tandemSet), function (key) {\n    var isBad = !values.hasOwnProperty(key);\n    if (isBad) {\n      console.error(\"bad tandem key: \" + key);\n    }\n    return isBad;\n  }).length === 0, \"Some tandem keys do not appear in the PropertySet\");\n\n  var propertySet = this;\n\n  Events.call(this);\n\n  //Keep track of the keys so we know which to reset\n  this.keys = [];\n\n  Object.getOwnPropertyNames(values).forEach(function (value) {\n    propertySet.addProperty(value, values[value], options.tandemSet[value]);\n  });\n};\n\ninherit(Events, PropertySet, {\n\n  /**\n   * Adds a new property to this PropertySet\n   * @param {string} propertyName\n   * @param {*} value the property's initial value\n   * @param {Tandem} [tandem] - optional support for tandem\n   */\n  addProperty: function addProperty(propertyName, value, tandem) {\n    this[propertyName + SUFFIX] = new Property(value, { tandem: tandem });\n    this.addGetterAndSetter(propertyName);\n    this.keys.push(propertyName);\n  },\n\n  /**\n   * Remove any property (whether a derived property or not) that was added to this PropertySet\n   * @param {String} propertyName\n   */\n  removeProperty: function removeProperty(propertyName) {\n\n    //Remove from the keys (only for non-derived properties)\n    var index = this.keys.indexOf(propertyName);\n    if (index !== -1) {\n      this.keys.splice(index, 1);\n    }\n\n    this[propertyName + SUFFIX].dispose();\n\n    //Unregister the Property instance from the PropertySet\n    delete this[propertyName + SUFFIX];\n\n    //Unregister the getter/setter, if they exist\n    delete this[propertyName];\n  },\n\n  /**\n   * Adds a getter and setter using ES5 get/set syntax, similar to https://gist.github.com/dandean/1292057, same as in github/Atlas\n   * @param {string} propertyName\n   */\n  addGetterAndSetter: function addGetterAndSetter(propertyName) {\n    var property = this[propertyName + SUFFIX];\n\n    Object.defineProperty(this, propertyName, {\n\n      // Getter proxies to Model#get()...\n      get: function get() {\n        return property.get();\n      },\n\n      // Setter proxies to Model#set(attributes)\n      set: function set(value) {\n        property.set(value);\n      },\n\n      // Make it configurable and enumerable so it's easy to override...\n      configurable: true,\n      enumerable: true\n    });\n  },\n\n  /**\n   * Adds an ES5 getter to a property.\n   * @param {string} propertyName\n   */\n  addGetter: function addGetter(propertyName) {\n    var property = this[propertyName + SUFFIX];\n\n    Object.defineProperty(this, propertyName, {\n\n      get: function get() {\n        return property.get();\n      },\n\n      // Make it configurable and enumerable so it's easy to override...\n      configurable: true,\n      enumerable: true\n    });\n  },\n\n  // Resets all of the properties associated with this PropertySet\n  reset: function reset() {\n    var propertySet = this;\n    this.keys.forEach(function (key) {\n      propertySet[key + SUFFIX].reset();\n    });\n  },\n\n  /**\n   * Creates a DerivedProperty from the given property property names and derivation.\n   * @param {string[]} propertyNames\n   * @param {function} derivation\n   * @param {Tandem} [tandem] - optional support for tandem\n   * @returns {DerivedProperty}\n   */\n  toDerivedProperty: function toDerivedProperty(propertyNames, derivation, tandem) {\n    return new DerivedProperty(this.getProperties(propertyNames), derivation, { tandem: tandem });\n  },\n\n  /**\n   * Adds a derived property to the property set.\n   * @param {string} propertyName name for the derived property\n   * @param {string[]} dependencyNames names of the properties that it depends on\n   * @param {function} derivation function that expects args in the same order as dependencies\n   * @param {Tandem} [tandem] - optional support for tandem\n   */\n  addDerivedProperty: function addDerivedProperty(propertyName, dependencyNames, derivation, tandem) {\n    this[propertyName + SUFFIX] = this.toDerivedProperty(dependencyNames, derivation, tandem);\n    this.addGetter(propertyName);\n  },\n\n  /**\n   * Returns an array of the requested properties.\n   * @param propertyNames\n   * @returns {*}\n   * @private\n   */\n  getProperties: function getProperties(propertyNames) {\n    var propertySet = this;\n    return propertyNames.map(function (propertyName) {\n      var propertyKey = propertyName + SUFFIX;\n      assert && assert(propertySet.hasOwnProperty(propertyKey));\n      return propertySet[propertyKey];\n    });\n  },\n\n  /**\n   * Set all of the values specified in the object hash\n   * Allows you to use this form:\n   * puller.set( {x: knot.x, y: knot.y, knot: knot} );\n   *\n   * instead of this:\n   * puller.x.value = knot.x;\n   * puller.y.value = knot.y;\n   * puller.knot.value = knot;\n   *\n   * Throws an error if you try to set a value for which there is no property.\n   */\n  setValues: function setValues(values) {\n    var propertySet = this;\n    Object.getOwnPropertyNames(values).forEach(function (propertyName) {\n      if (typeof (propertySet[propertyName + SUFFIX] === \"Property\")) {\n        propertySet[propertyName + SUFFIX].set(values[propertyName]);\n      } else {\n        throw new Error(\"property not found: \" + propertyName);\n      }\n    });\n  },\n\n  /**\n   * Get a JS object literal with all the current values of the properties in this property set, say for serialization.  See `set`\n   * TODO: this works well to serialize numbers, strings, booleans.  How to handle complex state values such as Vector2 or nested Property?  Maybe that must be up to the client code.\n   * TODO: This was named 'get' to mirror the 'set' method above, but I'm concerned this will make them difficult to find/replace and may confuse with real getters & setters.  Maybe setState/getState would be better?\n   */\n  getValues: function getValues() {\n    var state = {};\n    for (var i = 0; i < this.keys.length; i++) {\n      var key = this.keys[i];\n      state[key] = this.property(key).value;\n    }\n    return state;\n  },\n\n  /**\n   * Link to a property by name, see https://github.com/phetsims/axon/issues/16\n   * @param {string} propertyName the name of the property to link to\n   * @param {function }observer the callback to link to the property\n   */\n  link: function link(propertyName, observer) {\n    this[propertyName + SUFFIX].link(observer);\n  },\n\n  /**\n   * Unlink for a property by name, see https://github.com/phetsims/axon/issues/16\n   * @param {string} propertyName the name of the property to link to\n   * @param {function }observer the callback to link to the property\n   */\n  unlink: function unlink(propertyName, observer) {\n    this[propertyName + SUFFIX].unlink(observer);\n  },\n\n  /**\n   * Link an attribute to a property by name.  Return a handle to the observer so it can be removed using unlink().\n   * @param {string} propertyName the property to link to\n   * @param {object} object the object for which the attribute will be set\n   * @param {string} attributeName the name of the attribute to set on the object\n   */\n  linkAttribute: function linkAttribute(propertyName, object, attributeName) {\n    return this.property(propertyName).linkAttribute(object, attributeName);\n  },\n\n  /**\n   * Unlink an observer added with linkAttribute.  Note: the args of linkAttribute do not match the args of\n   * unlinkAttribute: here, you must pass the observer handle returned by linkAttribute rather than object and attributeName\n   * @param {string} propertyName - the name of the property that the observer will be removed from\n   * @param {function} observer\n   */\n  unlinkAttribute: function unlinkAttribute(propertyName, observer) {\n    this.property(propertyName).unlink(observer);\n  },\n\n  /**\n   * Registers an observer with multiple properties, then notifies the observer immediately.\n   * @param {string[]} propertyNames\n   * @param {function} observer no params, returns nothing\n   */\n  multilink: function multilink(propertyNames, observer) {\n    return new Multilink(this.getProperties(propertyNames), observer, false);\n  },\n\n  lazyMultilink: function lazyMultilink(propertyNames, observer) {\n    return new Multilink(this.getProperties(propertyNames), observer, true);\n  },\n\n  /**\n   * Removes the multilink from this PropertySet.\n   * Same as calling dispose() on the multilink\n   * @param {Multilink} multilink\n   */\n  unmultilink: function unmultilink(multilink) {\n    multilink.dispose();\n  },\n\n  toString: function toString() {\n    var text = \"PropertySet{\";\n    var propertySet = this;\n    for (var i = 0; i < this.keys.length; i++) {\n      var key = this.keys[i];\n      text = text + key + \":\" + propertySet[key].toString();\n      if (i < this.keys.length - 1) {\n        text = text + \",\";\n      }\n    }\n    return text + \"}\";\n  },\n\n  /**\n   * Get a property by name, see https://github.com/phetsims/axon/issues/16\n   * @param {string} propertyName the name of the property to get\n   */\n  property: function property(propertyName) {\n    return this[propertyName + SUFFIX];\n  },\n\n  /**\n   * When the PropertySet is no longer used by the sim, it can be eliminated.  All Properties are disposed.\n   */\n  dispose: function dispose() {\n    for (var i = 0; i < this.keys.length; i++) {\n      this[this.keys[i] + SUFFIX].dispose();\n    }\n  }\n});\n\nmodule.exports = PropertySet;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./app/scripts/axon/PropertySet.js\n ** module id = 7\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./app/scripts/axon/PropertySet.js?");

/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	eval("\n/**\n * A Multilink is an instance that can be used to link to multiple properties.  It is very similar to a DerivedProperty, but has no value and does not conform to the Property API,\n * because it is intended for use with callbacks that do not compute a value.  Multilink should not be created through calling its constructor directly,\n * but through the Property.multilink and Property.lazyMultilink functions.\n *\n * @author Sam Reid\n */\n\n\"use strict\";\n\nvar inherit = __webpack_require__(3);\n\n/**\n * @param {Property[]} dependencies\n * @param {function} callback function that expects args in the same order as dependencies\n * @param {boolean} [lazy] Optional parameter that can be set to true if this should be a lazy multilink (no immediate callback)\n * @constructor\n */\nvar Multilink = function Multilink(dependencies, callback, lazy) {\n  this.dependencies = dependencies;\n\n  //Keep track of each dependency and only update the changed value, for speed\n  this.dependencyValues = dependencies.map(function (property) {\n    return property.get();\n  });\n\n  var multilink = this;\n\n  //Keep track of listeners so they can be detached\n  this.dependencyListeners = [];\n\n  //When a dependency value changes, update the list of dependencies and call back to the callback\n  for (var i = 0; i < dependencies.length; i++) {\n    var dependency = dependencies[i];\n    (function (dependency, i) {\n      var listener = function listener(newValue) {\n        multilink.dependencyValues[i] = newValue;\n        callback.apply(null, multilink.dependencyValues);\n      };\n      multilink.dependencyListeners.push(listener);\n      dependency.lazyLink(listener);\n    })(dependency, i);\n  }\n\n  //Send initial call back but only if we are non-lazy\n  if (!lazy) {\n    callback.apply(null, this.dependencyValues);\n  }\n};\n\ninherit(Object, Multilink, {\n\n  dispose: function dispose() {\n    // Unlink from dependent properties\n    for (var i = 0; i < this.dependencies.length; i++) {\n      var dependency = this.dependencies[i];\n      dependency.unlink(this.dependencyListeners[i]);\n    }\n    this.dependencies = null;\n    this.dependencyListeners = null;\n    this.dependencyValues = null;\n  }\n});\n\nmodule.exports = Multilink;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./app/scripts/axon/Multilink.js\n ** module id = 8\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./app/scripts/axon/Multilink.js?");

/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	eval("\n\n/**\n * A DerivedProperty is computed based on other properties.  This implementation inherits from Property to (a) simplify\n * implementation and (b) ensure it remains consistent. Note that the setters should not be called directly, so the\n * setters (set, reset and es5 setter) throw an error if used directly.\n *\n * @author Sam Reid\n */\n\n// modules\n\"use strict\";\n\nvar Property = __webpack_require__(2);\nvar inherit = __webpack_require__(3);\n\n/**\n * @param {Property[]} dependencies properties that this property's value is derived from\n * @param {function} derivation function that derives this property's value, expects args in the same order as dependencies\n * @param {object} [options] - see Property\n * @constructor\n */\nvar DerivedProperty = function DerivedProperty(dependencies, derivation, options) {\n  this.dependencies = dependencies;\n\n  //Keep track of each dependency and only update the changed value, for speed\n  this.dependencyValues = dependencies.map(function (property) {\n    return property.get();\n  });\n\n  var initialValue = derivation.apply(null, this.dependencyValues);\n  Property.call(this, initialValue, options);\n\n  var derivedProperty = this;\n\n  //Keep track of listeners so they can be detached\n  this.dependencyListeners = [];\n\n  for (var i = 0; i < dependencies.length; i++) {\n    var dependency = dependencies[i];\n    (function (dependency, i) {\n      var listener = function listener(newValue) {\n        derivedProperty.dependencyValues[i] = newValue;\n        Property.prototype.set.call(derivedProperty, derivation.apply(null, derivedProperty.dependencyValues));\n      };\n      derivedProperty.dependencyListeners.push(listener);\n      dependency.lazyLink(listener);\n    })(dependency, i);\n  }\n};\n\ninherit(Property, DerivedProperty, Object.defineProperties({\n\n  dispose: function dispose() {\n\n    Property.prototype.dispose.call(this);\n\n    // Unlink from dependent properties\n    for (var i = 0; i < this.dependencies.length; i++) {\n      var dependency = this.dependencies[i];\n      dependency.unlink(this.dependencyListeners[i]);\n    }\n    this.dependencies = null;\n    this.dependencyListeners = null;\n    this.dependencyValues = null;\n  },\n\n  //Override the mutators to provide an error message.  These should not be called directly, the value should only be modified when the dependencies change\n  set: function set(value) {\n    throw new Error(\"Cannot set values directly to a derived property, tried to set: \" + value);\n  },\n\n  //Override the mutators to provide an error message.  These should not be called directly, the value should only be modified when the dependencies change\n  reset: function reset() {\n    throw new Error(\"Cannot reset a derived property directly\");\n  }\n}, {\n  value: {\n    set: function (newValue) {\n      throw new Error(\"Cannot es5-set values directly to a derived property, tried to set: \" + newValue);\n    },\n    get: function () {\n      return Property.prototype.get.call(this);\n    },\n    configurable: true,\n    enumerable: true\n  }\n}));\n\nmodule.exports = DerivedProperty;\n\n//Override the mutators to provide an error message.  These should not be called directly, the value should only be modified when the dependencies change\n//Keep the newValue output in the string so the argument won't be stripped by minifier (which would cause crashes like https://github.com/phetsims/axon/issues/15)\n\n//Override get value as well to satisfy the linter which wants get/set pairs (even though it just uses the same code as the superclass).\n\n/*****************\n ** WEBPACK FOOTER\n ** ./app/scripts/axon/DerivedProperty.js\n ** module id = 9\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./app/scripts/axon/DerivedProperty.js?");

/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	eval("\n/**\n * A Multilink is an instance that can be used to link to multiple properties.  It is very similar to a DerivedProperty, but has no value and does not conform to the Property API,\n * because it is intended for use with callbacks that do not compute a value.  Multilink should not be created through calling its constructor directly,\n * but through the Property.multilink and Property.lazyMultilink functions.\n *\n * @author Sam Reid\n */\n\n\"use strict\";\n\nvar inherit = __webpack_require__(3);\n\n/**\n * @param {Property[]} dependencies\n * @param {function} callback function that expects args in the same order as dependencies\n * @param {boolean} [lazy] Optional parameter that can be set to true if this should be a lazy multilink (no immediate callback)\n * @constructor\n */\nvar Multilink = function Multilink(dependencies, callback, lazy) {\n  this.dependencies = dependencies;\n\n  //Keep track of each dependency and only update the changed value, for speed\n  this.dependencyValues = dependencies.map(function (property) {\n    return property.get();\n  });\n\n  var multilink = this;\n\n  //Keep track of listeners so they can be detached\n  this.dependencyListeners = [];\n\n  //When a dependency value changes, update the list of dependencies and call back to the callback\n  for (var i = 0; i < dependencies.length; i++) {\n    var dependency = dependencies[i];\n    (function (dependency, i) {\n      var listener = function listener(newValue) {\n        multilink.dependencyValues[i] = newValue;\n        callback.apply(null, multilink.dependencyValues);\n      };\n      multilink.dependencyListeners.push(listener);\n      dependency.lazyLink(listener);\n    })(dependency, i);\n  }\n\n  //Send initial call back but only if we are non-lazy\n  if (!lazy) {\n    callback.apply(null, this.dependencyValues);\n  }\n};\n\ninherit(Object, Multilink, {\n\n  dispose: function dispose() {\n    // Unlink from dependent properties\n    for (var i = 0; i < this.dependencies.length; i++) {\n      var dependency = this.dependencies[i];\n      dependency.unlink(this.dependencyListeners[i]);\n    }\n    this.dependencies = null;\n    this.dependencyListeners = null;\n    this.dependencyValues = null;\n  }\n});\n\nmodule.exports = Multilink;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./app/scripts/axon/MultiLink.js\n ** module id = 10\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./app/scripts/axon/MultiLink.js?");

/***/ },
/* 11 */
/***/ function(module, exports) {

	eval("// Copyright 2002-2014, University of Colorado Boulder\n\n/**\n * Removes a single (the first) matching object from an Array.\n *\n * @author Jonathan Olson <jonathan.olson@colorado.edu>\n */\n\n/*\n * @param {Array} arr\n * @param {*} item - The item to remove from the array\n */\n\"use strict\";\n\nvar arrayRemove = function arrayRemove(arr, item) {\n  assert && assert(arr instanceof Array, \"arrayRemove either takes an Array\");\n\n  var index = _.indexOf(arr, item);\n  assert && assert(index >= 0, \"item not found in Array\");\n\n  arr.splice(index, 1);\n};\n\nmodule.exports = arrayRemove;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./app/scripts/axon/arrayRemove.js\n ** module id = 11\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./app/scripts/axon/arrayRemove.js?");

/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	eval("/**\n * Abstraction for timed-event series that helps with variable frame-rates. Useful for things that need to happen at a\n * specific rate real-time regardless of the frame-rate.\n *\n * An EventTimer is created with a specific event \"model\" that determines when events occur, and a callback that will\n * be triggered for each event (with its time elapsed since it should have occurred).\n *\n * To run the EventTimer, call step( realTimeElapsed ), and it will call your callback for every event that would have\n * occurred over that time-frame (possibly zero).\n *\n * For example, create a timer with a constant rate that it will fire events every 1 time units:\n *\n * var timer = new EventTimer( new EventTimer.ConstantEventModel( 1 ), function( timeElapsed ) {\n *   console.log( 'event with timeElapsed: ' + timeElapsed );\n * } );\n *\n * Stepping once for 1.5 time units will fire once (0.5 seconds since the \"end\" of the step), and will be 0.5 seconds\n * from the next step:\n *\n * timer.step( 1.5 );\n * > event with timeElapsed: 0.5\n *\n * Stepping for a longer time will result in more events:\n *\n * timer.step( 6 );\n * > event with timeElapsed: 5.5\n * > event with timeElapsed: 4.5\n * > event with timeElapsed: 3.5\n * > event with timeElapsed: 2.5\n * > event with timeElapsed: 1.5\n * > event with timeElapsed: 0.5\n *\n * A step with zero time will trigger no events:\n *\n * timer.step( 0 );\n *\n * The timer will fire an event once it reaches the exact point in time:\n *\n * timer.step( 1.5 );\n * > event with timeElapsed: 1\n * > event with timeElapsed: 0\n *\n * @author Jonathan Olson <jonathan.olson@colorado.edu>\n */\n\n\"use strict\";\n\nvar inherit = __webpack_require__(3);\n\n/*\n * Create an event timer with a specific model (determines the time between events), and a callback to be called\n * for events.\n *\n * @param {Object with getPeriodBeforeNextEvent(): Number} eventModel: getPeriodBeforeNextEvent() will be called at\n *    the start and after every event to determine the time required to pass by before the next event occurs.\n * @param {function} eventCallback( timeElapsed ): Will be called for every event. The timeElapsed passed in as the\n *    only argument denotes the time elapsed since the event would have occurred. E.g. if we step for 5 seconds and\n *    our event would have occurred 1 second into that step, the timeElapsed will be 4 seconds, since after the end\n *    of the 5 seconds the event would have happened 4 seconds ago.\n */\nvar EventTimer = function EventTimer(eventModel, eventCallback) {\n  assert && assert(typeof eventCallback === \"function\", \"EventTimer requires a callback\");\n\n  this.eventModel = eventModel;\n  this.eventCallback = eventCallback;\n\n  this.timeBeforeNextEvent = this.eventModel.getPeriodBeforeNextEvent();\n};\n\ninherit(Object, EventTimer, {\n  step: function step(dt) {\n    while (dt >= this.timeBeforeNextEvent) {\n      dt -= this.timeBeforeNextEvent;\n      this.timeBeforeNextEvent = this.eventModel.getPeriodBeforeNextEvent();\n\n      // how much time has elapsed since this event began\n      this.eventCallback(dt);\n    }\n\n    // use up the remaining DT\n    this.timeBeforeNextEvent -= dt;\n  }\n});\n\n/*\n * Event model that will fire events at a constant rate. An event will occur every 1/rate time units.\n * @param {number} rate\n */\nEventTimer.ConstantEventModel = inherit(Object, function ConstantEventRate(rate) {\n  assert && assert(typeof rate === \"number\", \"The rate should be a number\");\n  assert && assert(rate > 0, \"We need to have a strictly positive rate in order to prevent infinite loops.\");\n\n  this.rate = rate;\n}, {\n  getPeriodBeforeNextEvent: function getPeriodBeforeNextEvent() {\n    return 1 / this.rate;\n  }\n});\n\n/*\n * Event model that will fire events averaging a certain rate, but with the time between events being uniformly\n * random.\n * The pseudoRandomNumberSource, when called, should generate uniformly distributed random numbers in the range [0,1).\n * @param {number} rate\n * @param {function} pseudoRandomNumberSource() : Number\n */\nEventTimer.UniformEventModel = inherit(Object, function UniformEventModel(rate, pseudoRandomNumberSource) {\n  assert && assert(typeof rate === \"number\", \"The rate should be a number\");\n  assert && assert(typeof pseudoRandomNumberSource === \"function\", \"The pseudo-random number source should be a function\");\n  assert && assert(rate > 0, \"We need to have a strictly positive rate in order to prevent infinite loops.\");\n\n  this.rate = rate;\n  this.pseudoRandomNumberSource = pseudoRandomNumberSource;\n}, {\n  getPeriodBeforeNextEvent: function getPeriodBeforeNextEvent() {\n    var uniformRandomNumber = this.pseudoRandomNumberSource();\n    assert && assert(typeof uniformRandomNumber === \"number\" && uniformRandomNumber >= 0 && uniformRandomNumber < 1, \"Our uniform random number is outside of its expected range with a value of \" + uniformRandomNumber);\n\n    // sample the exponential distribution\n    return uniformRandomNumber * 2 / this.rate;\n  }\n});\n\n/*\n * Event model that will fire events corresponding to a Poisson process with the specified rate.\n * The pseudoRandomNumberSource, when called, should generate uniformly distributed random numbers in the range [0,1).\n * @param {number} rate\n * @param {function} pseudoRandomNumberSource() : number\n */\nEventTimer.PoissonEventModel = inherit(Object, function PoissonEventModel(rate, pseudoRandomNumberSource) {\n  assert && assert(typeof rate === \"number\", \"The time between events should be a number\");\n  assert && assert(typeof pseudoRandomNumberSource === \"function\", \"The pseudo-random number source should be a function\");\n  assert && assert(rate > 0, \"We need to have a strictly positive poisson rate in order to prevent infinite loops.\");\n\n  this.rate = rate;\n  this.pseudoRandomNumberSource = pseudoRandomNumberSource;\n}, {\n  getPeriodBeforeNextEvent: function getPeriodBeforeNextEvent() {\n    // A poisson process can be described as having an independent exponential distribution for the time between\n    // consecutive events.\n    // see http://en.wikipedia.org/wiki/Exponential_distribution#Generating_exponential_variates and\n    // http://en.wikipedia.org/wiki/Poisson_process\n\n    var uniformRandomNumber = this.pseudoRandomNumberSource();\n    assert && assert(typeof uniformRandomNumber === \"number\" && uniformRandomNumber >= 0 && uniformRandomNumber < 1, \"Our uniform random number is outside of its expected range with a value of \" + uniformRandomNumber);\n\n    // sample the exponential distribution\n    return -Math.log(uniformRandomNumber) / this.rate;\n  }\n});\n\nmodule.exports = EventTimer;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./app/scripts/axon/EventTimer.js\n ** module id = 12\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./app/scripts/axon/EventTimer.js?");

/***/ }
/******/ ]);