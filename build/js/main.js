/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_RESULT__;/**\r\n * Main entry point for the app.\r\n *\r\n * @author Sharfudeen Ashraf\r\n */\n\"use strict\";\n\n!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {\n  \"use strict\";\n  var SimLauncher = __webpack_require__(1);\n  var SimApp = __webpack_require__(2);\n  var SimScreen = __webpack_require__(4);\n\n  var EcoSystemModel = __webpack_require__(5);\n  var EcoSystemView = __webpack_require__(6);\n\n  var energySimTitle = \"EcoSystem Simulation\";\n  SimLauncher.launch(function () {\n    var options = { backgroundColor: \"rgb( 242, 255, 204 )\" /* Light yellow-green */ };\n    var createModel = function createModel() {\n      return new EcoSystemModel();\n    };\n\n    var createView = function createView(model) {\n      return new EcoSystemView(model);\n    };\n\n    var energySimScreen = new SimScreen(energySimTitle, createModel, createView);\n    var app = new SimApp(energySimTitle, energySimScreen, \"\\\"main-scene\", options);\n    //start rendering..\n    app.start();\n  });\n}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n/*****************\n ** WEBPACK FOOTER\n ** ./app/scripts/main.js\n ** module id = 0\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./app/scripts/main.js?");

/***/ },
/* 1 */
/***/ function(module, exports) {

	eval("/**\r\n * Launches the Simulation , after doing things like showing splash screen,loading images etc\r\n *\r\n * @author Sharfudeen Ashraf\r\n */\n\n\"use strict\";\n\nmodule.exports = {\n  /**\r\n   * Launch the Sim by preloading the images and calling the callback.\r\n   * @param callback the callback function which should create and start the sim, given that the images are loaded\r\n   */\n  launch: function launch(callback) {\n\n    //Need to do some preloading ,splash screen etc\n    callback();\n  }\n\n};\n\n/*****************\n ** WEBPACK FOOTER\n ** ./app/scripts/core/SimLauncher.js\n ** module id = 1\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./app/scripts/core/SimLauncher.js?");

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	eval("// modules\n\"use strict\";\n\nvar inherit = core.inherit;\nvar Shape = kite.Shape;\nvar Node = scenery.Node;\nvar Display = scenery.Display;\nvar Input = scenery.Input;\nvar PropertySet = axon.PropertySet;\nvar Bounds2 = dot.Bounds2;\nvar Dimension2 = dot.Dimension2;\nvar Util = scenery.Util;\nvar ObservableArray = axon.ObservableArray;\nvar Rectangle = scenery.Rectangle;\nvar ButtonListener = scenery.ButtonListener;\n\nvar Timer = __webpack_require__(3);\n\n// constants\nvar LAYOUT_BOUNDS = new Bounds2(0, 0, 768, 504);\n\n/**\r\n *\r\n * @param {TitleName} titleName\r\n * @param {Screen} screen\r\n * @param options\r\n * @constructor\r\n */\nfunction SimApp(titleName, screen, simId, options) {\n  var sim = this;\n  PropertySet.call(sim, {});\n\n  window.sim = this;\n\n  // update our scale and bounds properties after other changes (so listeners can be fired after screens are resized)\n  this.scale = 1;\n  this.bounds = new Bounds2(0, 0, 1, 1); // just place holder values\n  this.screenBounds = new Bounds2(0, 0, 1, 1);\n\n  //A screen is made up of Model and View (where View is a ScreenView - (just as Node, but has additional layout related functionality)\n  sim.model = screen.createModel();\n  sim.view = screen.createView(sim.model);\n  sim.rootNode = new Node();\n  sim.rootNode.addChild(sim.view);\n  sim.display = new Display(sim.rootNode, options);\n\n  var simDiv = sim.display.domElement;\n  simDiv.id = simId;\n  document.body.appendChild(simDiv);\n\n  // for preventing Safari from going to sleep. see https://github.com/phetsims/joist/issues/140\n  var heartbeatDiv = this.heartbeatDiv = document.createElement(\"div\");\n  heartbeatDiv.style.opacity = 0;\n  document.body.appendChild(heartbeatDiv);\n  sim.heartbeatDiv = heartbeatDiv;\n\n  sim.display.initializeWindowEvents({ batchDOMEvents: false });\n\n  // number of animation frames that have occurred\n  sim.frameCounter = 0;\n\n  // layer for popups, dialogs, and their backgrounds and barriers\n  sim.topLayer = new Node({ renderer: \"svg\" });\n  sim.rootNode.addChild(this.topLayer);\n\n  // Semi-transparent black barrier used to block input events when a dialog (or other popup) is present, and fade\n  // out the background.\n  this.barrierStack = new ObservableArray();\n  this.barrierRectangle = new Rectangle(0, 0, 1, 1, 0, 0, {\n    fill: \"rgba(0,0,0,0.3)\",\n    pickable: true\n  });\n  this.topLayer.addChild(this.barrierRectangle);\n  this.barrierStack.lengthProperty.link(function (numBarriers) {\n    sim.barrierRectangle.visible = numBarriers > 0;\n  });\n  this.barrierRectangle.addInputListener(new ButtonListener({\n    fire: function fire(event) {\n      assert && assert(sim.barrierStack.length > 0);\n      sim.hidePopup(sim.barrierStack.get(sim.barrierStack.length - 1), true);\n    }\n  }));\n\n  this.active = true;\n  this.destroyed = false;\n\n  $(\"title\").html(titleName);\n\n  // Fit to the window and render the initial scene\n  $(window).resize(function () {\n    sim.resizeToWindow();\n  });\n  sim.resizeToWindow();\n}\n\ninherit(PropertySet, SimApp, {\n  /*\r\n   * Adds a popup in the global coordinate frame, and optionally displays a semi-transparent black input barrier behind it.\r\n   * Use hidePopup() to remove it.\r\n   * @param {Node} node\r\n   * @param {boolean} isModal - Whether to display the semi-transparent black input barrier behind it.\r\n   */\n  showPopup: function showPopup(node, isModal) {\n    if (isModal) {\n      this.barrierStack.push(node);\n    }\n    this.topLayer.addChild(node);\n\n    Input.pushFocusContext(node.getTrails()[0]);\n  },\n\n  /*\r\n   * Hides a popup that was previously displayed with showPopup()\r\n   * @param {Node} node\r\n   * @param {boolean} isModal - Whether the previous popup was modal (or not)\r\n   */\n  hidePopup: function hidePopup(node, isModal) {\n\n    if (isModal) {\n      this.barrierStack.remove(node);\n    }\n    Input.popFocusContext(node.getTrails()[0]);\n\n    this.topLayer.removeChild(node);\n  },\n\n  resizeToWindow: function resizeToWindow() {\n    this.resize(window.innerWidth, window.innerHeight);\n  },\n\n  resize: function resize(width, height) {\n    var sim = this;\n\n    var scale = Math.min(width / LAYOUT_BOUNDS.width, height / LAYOUT_BOUNDS.height);\n\n    this.barrierRectangle.rectWidth = width;\n    this.barrierRectangle.rectHeight = height;\n\n    sim.display.setSize(new Dimension2(width, height));\n\n    var screenHeight = height;\n\n    // Layout the view\n    sim.view.layout(width, screenHeight);\n\n    // Startup can give spurious resizes (seen on ipad), so defer to the animation loop for painting\n\n    sim.display._input.eventLog.push(\"scene.display.setSize(new dot.Dimension2(\" + width + \",\" + height + \"));\");\n\n    // Fixes problems where the div would be way off center on iOS7\n    // TODO\n    /* if ( platform.mobileSafari ) {\r\n       window.scrollTo( 0, 0 );\r\n     }*/\n\n    // update our scale and bounds properties after other changes (so listeners can be fired after screens are resized)\n    this.scale = scale;\n    this.bounds = new Bounds2(0, 0, width, height);\n    this.screenBounds = new Bounds2(0, 0, width, screenHeight);\n\n    this.trigger(\"resized\", this.bounds, this.screenBounds, this.scale);\n  },\n\n  start: function start() {\n    //Keep track of the previous time for computing dt, and initially signify that time hasn't been recorded yet.\n    var lastTime = -1;\n\n    var sim = this;\n    //Make sure requestAnimationFrame is defined\n    Util.polyfillRequestAnimationFrame();\n\n    // place the rAF *before* the render() to assure as close to 60fps with the setTimeout fallback.\n    //http://paulirish.com/2011/requestanimationframe-for-smart-animating/\n    (function animationLoop() {\n      var dt;\n\n      sim.profiler && sim.profiler.frameStarted();\n\n      // increment this before we can have an exception thrown, to see if we are missing frames\n      sim.frameCounter++;\n\n      if (!sim.destroyed) {\n        window.requestAnimationFrame(animationLoop);\n      }\n\n      // prevent Safari from going to sleep, see https://github.com/phetsims/joist/issues/140\n      if (sim.frameCounter % 1000 === 0) {\n        sim.heartbeatDiv.innerHTML = Math.random();\n      }\n\n      //Compute the elapsed time since the last frame, or guess 1/60th of a second if it is the first frame\n      var time = Date.now();\n      var elapsedTimeMilliseconds = lastTime === -1 ? 1000 / 60 : time - lastTime;\n      lastTime = time;\n\n      //Convert to seconds\n      dt = elapsedTimeMilliseconds / 1000;\n\n      // Step the models, timers and tweens, but only if the sim is active.\n      // It may be inactive if it has been paused through the SimIFrameAPI\n      if (sim.active) {\n\n        //The place where we start custom animations\n        if (sim.model.step) {\n          sim.model.step(dt);\n        }\n\n        //The place where we start custom animations\n        if (sim.view.step) {\n          sim.view.step(dt);\n        }\n\n        Timer.step(dt);\n\n        //If using the TWEEN animation library, then update all of the tweens (if any) before rendering the scene.\n        //Update the tweens after the model is updated but before the scene is redrawn.\n        if (window.TWEEN) {\n          window.TWEEN.update();\n        }\n      }\n      sim.display.updateDisplay();\n\n      sim.profiler && sim.profiler.frameEnded();\n\n      sim.trigger(\"frameCompleted\");\n    })();\n  }\n});\n\nmodule.exports = SimApp;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./app/scripts/core/SimApp.js\n ** module id = 2\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./app/scripts/core/SimApp.js?");

/***/ },
/* 3 */
/***/ function(module, exports) {

	eval("\"use strict\";\n\nvar cleanArray = axon.cleanArray;\n\nvar listeners = [];\nvar listenersDefensiveCopy = []; // separated out to prevent garbage collection issues\n\nmodule.exports = {\n\n  //Trigger a step event, called by Sim.js in the animation loop\n  step: function step(dt) {\n    var length = listeners.length;\n    var i;\n\n    // to safely allow listeners to remove themselves while being called (as is explicitly done in setTimeout), we make a copy of the array.\n    // we don't use slice(), since that would cause garbage collection issues.\n    for (i = 0; i < length; i++) {\n      listenersDefensiveCopy[i] = listeners[i];\n    }\n    for (i = 0; i < length; i++) {\n      listenersDefensiveCopy[i](dt);\n    }\n    cleanArray(listenersDefensiveCopy);\n  },\n\n  //Add a listener to be called back once after the specified time (in milliseconds)\n  setTimeout: function setTimeout(listener, timeout) {\n    var elapsed = 0;\n    var timer = this;\n    var callback = (function (_callback) {\n      var _callbackWrapper = function callback(_x) {\n        return _callback.apply(this, arguments);\n      };\n\n      _callbackWrapper.toString = function () {\n        return _callback.toString();\n      };\n\n      return _callbackWrapper;\n    })(function (dt) {\n      elapsed += dt;\n\n      //Convert seconds to ms and see if item has timed out\n      if (elapsed * 1000 >= timeout) {\n        listener();\n        timer.removeStepListener(callback);\n      }\n    });\n    this.addStepListener(callback);\n\n    //Return the callback so it can be removed with removeStepListener\n    return callback;\n  },\n\n  //Clear a scheduled timeout. If there was no timeout, nothing is done.\n  clearTimeout: function clearTimeout(timeoutID) {\n    if (this.hasStepListener(timeoutID)) {\n      this.removeStepListener(timeoutID);\n    }\n  },\n\n  //Add a listener to be called at specified intervals (in milliseconds)\n  setInterval: function setInterval(listener, interval) {\n    var elapsed = 0;\n    var callback = (function (_callback) {\n      var _callbackWrapper = function callback(_x) {\n        return _callback.apply(this, arguments);\n      };\n\n      _callbackWrapper.toString = function () {\n        return _callback.toString();\n      };\n\n      return _callbackWrapper;\n    })(function (dt) {\n      elapsed += dt;\n\n      //Convert seconds to ms and see if item has timed out\n      while (elapsed * 1000 >= interval && listeners.indexOf(callback) !== -1) {\n        listener();\n        elapsed = elapsed - interval / 1000; //Save the leftover time so it won't accumulate\n      }\n    });\n    this.addStepListener(callback);\n\n    //Return the callback so it can be removed with removeStepListener\n    return callback;\n  },\n\n  //Clear a scheduled interval. If there was no interval, nothing is done.\n  clearInterval: function clearInterval(intervalID) {\n    if (this.hasStepListener(intervalID)) {\n      this.removeStepListener(intervalID);\n    }\n  },\n\n  //Add a listener to be called back on every animationFrame with a dt value\n  addStepListener: function addStepListener(listener) {\n    listeners.push(listener);\n  },\n\n  //Remove a step listener from being called back\n  removeStepListener: function removeStepListener(listener) {\n    var index = listeners.indexOf(listener);\n    assert && assert(index !== -1, \"An attempt was made to remove a non-existent step listener\");\n    if (index !== -1) {\n      listeners.splice(index, 1);\n    }\n  },\n\n  hasStepListener: function hasStepListener(listener) {\n    return listeners.indexOf(listener) >= 0;\n  }\n};\n\n/*****************\n ** WEBPACK FOOTER\n ** ./app/scripts/core/Timer.js\n ** module id = 3\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./app/scripts/core/Timer.js?");

/***/ },
/* 4 */
/***/ function(module, exports) {

	eval("/**\r\n *\r\n * @author Sharfudeen Ashraf\r\n */\n\n\"use strict\";\n\nvar inherit = axon.inherit;\nvar PropertySet = axon.PropertySet;\nvar Color = scenery.Color;\n\n/**\r\n * @param {string} name\r\n * @param {function} createModelCallback\r\n * @param {function} createViewCallback\r\n * @param {Object} [options]\r\n * @constructor\r\n */\nfunction Screen(name, createModelCallback, createViewCallback, options) {\n\n  options = _.extend({\n    backgroundColor: \"white\" // {Color|string} - Initial background color of the screen\n  }, options);\n\n  var backgroundColor = options.backgroundColor;\n  if (typeof backgroundColor === \"string\") {\n    backgroundColor = new Color(backgroundColor);\n  }\n\n  PropertySet.call(this, {\n    backgroundColor: backgroundColor\n  });\n\n  this.name = name;\n  this.createModel = createModelCallback;\n  this.createView = createViewCallback;\n}\n\ninherit(PropertySet, Screen);\n\nmodule.exports = Screen;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./app/scripts/core/Screen.js\n ** module id = 4\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./app/scripts/core/Screen.js?");

/***/ },
/* 5 */
/***/ function(module, exports) {

	eval("/**\r\n * The main model containing - EcoSystem\r\n * @author Sharfudeen Ashraf\r\n *\r\n */\n\n// modules\n\"use strict\";\n\nvar inherit = core.inherit;\n\nfunction EcoSystemModel() {}\n\ninherit(Object, EcoSystemModel, {\n  /**\r\n   * model related animation\r\n   * @param dt\r\n   */\n  step: function step(dt) {}\n});\n\nmodule.exports = EcoSystemModel;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./app/scripts/model/EcoSystemModel.js\n ** module id = 5\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./app/scripts/model/EcoSystemModel.js?");

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	eval("/**\r\n * The main model containing - EcoSystem\r\n * @author Sharfudeen Ashraf\r\n *\r\n */\n\n\"use strict\";\n\nvar inherit = core.inherit;\nvar Bounds2 = dot.Bounds2;\nvar BaseScreenView = __webpack_require__(7);\n\nfunction EcoSystemView(model) {\n  var thisView = this;\n  BaseScreenView.call(thisView, { layoutBounds: new Bounds2(0, 0, 981, 604) });\n}\n\ninherit(BaseScreenView, EcoSystemView, {\n  /**\r\n   * view related animation\r\n   * @param dt\r\n   */\n  step: function step(dt) {}\n});\n\nmodule.exports = EcoSystemView;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./app/scripts/view/EcoSystemView.js\n ** module id = 6\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./app/scripts/view/EcoSystemView.js?");

/***/ },
/* 7 */
/***/ function(module, exports) {

	eval("/**\r\n *\r\n *\r\n * @author Sharfudeen Ashraf\r\n */\n\n\"use strict\";\n\nvar Node = scenery.Node;\nvar inherit = core.inherit;\nvar Bounds2 = dot.Bounds2;\n\nvar DEFAULT_LAYOUT_BOUNDS = new Bounds2(0, 0, 1024, 618);\n\nfunction BaseScreenView(options) {\n\n  options = _.extend({\n    layoutBounds: DEFAULT_LAYOUT_BOUNDS.copy()\n  }, options);\n  this.layoutBounds = options.layoutBounds;\n\n  Node.call(this, _.extend({\n    layerSplit: true // so we're not in the same layer as the navbar, etc.\n  }, options));\n}\n\ninherit(Node, BaseScreenView, {\n\n  //Get the scale to use for laying out the sim components and the navigation bar, so its size will track with the sim size\n  getLayoutScale: function getLayoutScale(width, height) {\n    return Math.min(width / this.layoutBounds.width, height / this.layoutBounds.height);\n  },\n\n  //Default layout function uses the layoutWidth and layoutHeight to scale the content (based on whichever is more\n  // limiting: width or height)\n  //and centers the content in the screen vertically and horizontally\n  //This function can be replaced by subclasses that wish to perform their own custom layout.\n  layout: function layout(width, height) {\n    this.resetTransform();\n\n    var scale = this.getLayoutScale(width, height);\n    this.setScaleMagnitude(scale);\n\n    //center vertically\n    if (scale === width / this.layoutBounds.width) {\n      this.translate(0, (height - this.layoutBounds.height * scale) / 2 / scale);\n    }\n\n    //center horizontally\n    else if (scale === height / this.layoutBounds.height) {\n      this.translate((width - this.layoutBounds.width * scale) / 2 / scale, 0);\n    }\n  }\n},\n\n//statics\n{\n  DEFAULT_LAYOUT_BOUNDS: DEFAULT_LAYOUT_BOUNDS\n});\n\nmodule.exports = BaseScreenView;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./app/scripts/core/BaseScreenView.js\n ** module id = 7\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./app/scripts/core/BaseScreenView.js?");

/***/ }
/******/ ]);